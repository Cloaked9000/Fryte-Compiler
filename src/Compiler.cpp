#include "Compiler.h"

Compiler::Compiler()
{
    //ctor
}

Compiler::~Compiler()
{
    //dtor
}

int Compiler::stringToInstruction(const std::string& operation)
{
    if(operation == "+")
        return Instruction::MATH_ADD;
    else if(operation == "-")
        return Instruction::MATH_SUBTRACT;
    else if(operation == "*")
        return Instruction::MATH_MULTIPLY;
    else if(operation == "/")
        return Instruction::MATH_DIVIDE;
    else if(operation == "%")
        return Instruction::MATH_MOD;
    return -1; //Not found
}

DataType Compiler::stringToDataType(const std::string& type)
{
    if(type == "int")
        return DataType::INT;
    else if(type == "string")
        return DataType::STRING;
    else if(type == "char")
        return DataType::CHAR;
    else if(type == "bool")
        return DataType::BOOL;
    return DataType::NIL; //Not found
}

void Compiler::extractBracket(std::string bracket, std::vector<std::string> &results)
{
    //Ensure that data is not empty
    if(bracket.empty())
        return;

    //Now extract all bracket contents
    unsigned int bracketDepth = 0;
    unsigned int bracketBeginPos = 0;
    for(unsigned int a = 0; a < bracket.size(); a++)
    {
        //Each operator gets its own element in the results
        if((bracket[a] == '+' || bracket[a] == '-' || bracket[a] == '*') && bracketDepth == 0)
            results.emplace_back(std::string(1, bracket[a]));

        //If another bracket layer is opening, keep track of the bracket depth
        else if(bracket[a] == '(')
        {
            if(bracketDepth == 0)
                bracketBeginPos = a+1;
            bracketDepth++;
        }
        //If the current bracket is closing, keep track of current depth
        else if(bracket[a] == ')')
        {
            bracketDepth--;
            if(bracketDepth == 0) //If we've reached the end of the first bracket we checked
            {
                //Extract the bracket
                std::string foundBracket = bracket.substr(bracketBeginPos, a-bracketBeginPos);
                size_t found = foundBracket.find('(');
                if(found == std::string::npos)
                    results.emplace_back(foundBracket); //Emplace data if the extracted bracket doesn't contain another bracket
                else
                    extractBracket(foundBracket, results); //If it does contain another bracket, recursively call extractBracket on it
            }

        }
    }
}

void Compiler::bracketToBytecode(std::string bracket)
{
    //If the bracket just contains an operator, add a matching math instruction
    int operatorType = stringToInstruction(bracket);
    if(operatorType != -1) //If it's a valid operator
    {
        bytecode.emplace_back(operatorType);
        bytecode.emplace_back(resultsAdded);
        resultsAdded = 1;
        return;
    }


    //Sort through more complex brackets
    std::string numberBuffer;
    int currentEquationSize = 0;
    for(const auto &c : bracket)
    {
        operatorType = stringToInstruction(std::string(1, c));
        if(c == ' ' && !numberBuffer.empty()) //We've found a chunk of information, add it as a variable or if its a variable bring it to the top of the stack
        {
            bool isVariable = false;
            //See if the section of the bracket contains a variable
            for(unsigned int a = 0; a < stack.size(); a++)
            {
                if(stack[a].identifier == numberBuffer)
                {
                    isVariable = true;
                    bytecode.emplace_back(Instruction::CLONE_TOP);
                    bytecode.emplace_back(stack[a].stackPosition);
                    currentEquationSize++;
                    a = stack.size();
                }
            }
            if(isVariable == false) //If it's not a variable, then it's a number so add it to the stack
            {
                currentEquationSize++;
                bytecode.emplace_back(Instruction::CREATE_INT);
                bytecode.emplace_back(stoi(numberBuffer));
            }
            numberBuffer.clear();
        }

        //If operator, add appropriate math instruction
        else if(operatorType != -1)
        {
            //Generate bytecode relevant to this operator
            bytecode.emplace_back(operatorType);
            resultsAdded++;

            //Store generated bytecode
            bytecode.emplace_back(currentEquationSize);
            numberBuffer.clear();
            currentEquationSize = 0;
        }
        else
        {
            numberBuffer += c;
        }
    }
}

std::string Compiler::bracketOperatorFix(const std::string &data)
{
    //Convert things like "((1 + 2) + (3 * 4))" to "((1 2 +) (3 4 *) +)"

    std::string returnValue; //Store what the function will return as it's generated
    unsigned int currentLayer = 0; //To keep track of the current bracket layer
    std::map<unsigned int, char> bracketOperators; //Keep track of each bracket layer's operator. Map to keep track of multiple layers of brackets. map<LAYER, OPERATOR>

    //Find operators and data
    for(unsigned int a = 0; a < data.size(); a++)
    {
        //If new bracket, update bracket layer and set the layer's default operator (+)
        if(data[a] == '(')
        {
            currentLayer++;
            bracketOperators[currentLayer] = '+';
            returnValue += data[a];
        }

        //If we're exiting a bracket, update the layer and insert a space followed by this layer's operator
        else if(data[a] == ')')
        {
            returnValue += ' ';
            returnValue += bracketOperators[currentLayer];
            returnValue += data[a];
            currentLayer--;
        }

        //Else if an operator, don't add the operator to the return value and store this layer's operator
        else if(stringToInstruction(std::string(1, data[a])) != -1)
        {
            bracketOperators[currentLayer] = data[a];
            returnValue.erase(returnValue.size()-1, 1);
        }

        //Else, store current character. Not important.
        else
        {
            returnValue += data[a];
        }
    }
    return returnValue;
}

void Compiler::compileBracket(const std::string &bracket)
{
    if(bracket.find('"') == std::string::npos) //If not a string
    {
        resultsAdded = 0;
        std::vector<std::string> bracketSections;
        std::string bracketBuffer = bracketOperatorFix(bracket);
        extractBracket(bracketBuffer, bracketSections);
        for(auto &section : bracketSections)
        {
            //Compile bracket
            bracketToBytecode(section);
        }
    }
    else //Else string
    {
        bytecode.emplace_back(Instruction::CREATE_STRING);
        bytecode.emplace_back(bracket.size());
        for(unsigned int a = 0; a < bracket.size(); a++)
        {
            bytecode.emplace_back(bracket[a]);
        }
    }
}

std::vector<unsigned char> Compiler::compileSource(const std::vector<std::string>& source)
{
    bytecode.clear();
    for(unsigned int a = 0; a < source.size(); a++)
    {
        if(stringToDataType(source[a]) != DataType::NIL) //If data type is being created
        {
            DataType type = stringToDataType(source[a]);

            std::string identifier = source[++a]; //Example: 'varName'
            std::cout << "\nIdentifier: " << identifier;

            stack.emplace_back(Variable(identifier, stack.size(), type));

            std::string operation = source[++a]; //Example: '+'
            std::cout << "\nOperator: " << operation;
            if(operation == "=")
            {
                std::cout << "\nCompiling: " << source[a+1];
                compileBracket(source[++a]);
            }
        }
        else if(source[a] == "Console")
        {
            std::string operation = source[++a]; //Example: 'scan' or 'print'
            if(operation == "print")
            {
                compileBracket(source[++a]);
                bytecode.emplace_back(Instruction::CONSOLE_OUT);
            }
            else if(operation == "scan")
            {

            }
            else
            {
                throw std::string(source[a] + " has no operation named '" + operation + "'");
            }
        }
        else
        {
            throw std::string(source[a] + " was not declared in this scope");
        }
    }
    return bytecode;
}
